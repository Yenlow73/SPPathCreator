
# A modified version of a partition algorithm
    
    '''
        1 sp_phrase = 0 
        [] 
        2 sp_phrases =  1
        [[(2, 0)]]
        3 sp_phrases = 3
        [[(2, 0)], [(2, 1)], [(3, 0)]]
        4 sp_phrases = 7
        [*[(2, 0)]*, [(2, 1)], [(3, 0)], "[(2, 2)]", [(2, 0), (2, 0)], [(3, 1)], [(4, 0)]] 
        5 sp_phrases = 13
        [*[(2, 0)]*, *[(2, 1)]*, *[(3, 0)]*, "[(2, 2)]", [(2, 0), (2, 0)], [(3, 1)], [(4, 0)],
         [(2, 0), (3, 0)], [(2, 1), (2, 0)], [(3, 0), (2, 0)], [(4, 1)]]
        and so on...
    ''' 
    def calc_phrase_sums(self, n):
        # A modified version of a "Generate all unique partitions of an integer" algorithm 
        if n == 1:
            return [[(1, 0)]]

        partitions = []    

        partition = [0] * n # An array to store a partition
        k = 0  # Index of last element in a partition
        partition[k] = n
  
        # This loop first prints current partition, then generates next
        # partition. The loop stops when the current partition has all 1s
        while True:
            # print current partition
            c_partition = [i for i in partition if i > 0]
            c_partition = c_partition[0:(k + 1)]
            partitions.append(c_partition)
  
            # Generate next partition
  
            # Find the rightmost non-one value in p[]. Also, update the
            # rem_val so that we know how much value can be accommodated
            rem_val = 0
            while k >= 0 and partition[k] == 1: 
                rem_val += partition[k]
                k -= 1
            
            # if k < 0, all the values are 1 so there are no more partitions
            if k < 0:
                break
  
            # Decrease the partition[k] found above and adjust the rem_val
            partition[k] -= 1
            rem_val += 1
  
  
            # If rem_val is more, then the sorted order is violeted.  Divide
            # rem_val in differnt values of size partition[k] and copy these values at
            # different positions after partition[k]
            while rem_val > partition[k]:
                partition[k + 1] = partition[k]
                rem_val -= partition[k]
                k += 1
  
            # Copy rem_val to next position and increment position
            partition[k + 1] = rem_val
            k += 1

        for i in range(len(partitions)):
            j = 0
            while j < len(partitions[i]):
                if partitions[i][j] > 4:           
                    partitions[i].insert(j + 1, partitions[i][j] - 4)
                    partitions[i][j] = 4
                j += 1

        sums = []

        for x in partitions:
            if x not in sums:
                sums.append(x)

        #sums = [[(x, 0) for x in s] for s in sums]

        return sums


        '''
        # table[i] will store solutions for value i.
        # Initialize all table values as [].
        table = [[] for i in range(n + 1)]

        table[2].extend([[(2, 0)]])
        table[3].extend([[(2, 0)], [(2, 1)], [(3, 0)]])

        if n < 4:
            return table[n]
        
        for i in range(4, n + 1):
            table[i].extend(table[i - 1])

            if i % 2 == 0:
                length = len(table[i])
                for j in range(length):
                    if isinstance(table[i][j], tuple)
            else:
        


        
        # Base case (If given value is 2)
        table[2].append([(2, 0)])
    
        # One by one consider given 3 moves and update the
        # table[] solutions after the index greater than or equal
        # to the value of the picked move.
        for i in range(2, n + 1):
            table[i - 3].append(1)
            table[i - 3].append([3])

        for i in range(2, n + 1):
            table[i].append([(2, 0)])
        for i in range(3, n + 2):
            table[i - 1].append([(3, 0)])
            table[i].append([(3, 0)])
        for i in range(4, n + 1):
            table[i].append([(4, 0)])
        
        return table[n]
        '''

        '''
        def calc_phrase_sums(self, length):
            partitions = [[length]]
            for k in range(1, (length - 1)):
                partitions.extend([[(length - 1) - k] + l for l in partitions[k] if (length - 1) - k >= l[0]])
            return partitions
        '''